<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Logic Test Suite</title>
    <style>
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #fff;
            padding: 20px;
        }
        .test-result {
            margin: 10px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .test-pass {
            background: #2ed573;
            color: #000;
        }
        .test-fail {
            background: #ff6b6b;
            color: #fff;
        }
        .test-section {
            margin: 20px 0;
            border: 1px solid #00d4ff;
            padding: 15px;
            border-radius: 8px;
        }
        h2 {
            color: #00d4ff;
        }
        .expression-test {
            font-family: 'Courier New', monospace;
            background: rgba(0, 212, 255, 0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>üé≤ Dice Logic Test Suite</h1>
    <div id="test-results"></div>

    <script>
        // Copy the dice logic functions from character-sheet.js for testing
        function parseDiceExpression(expression) {
            // Clean and normalize the expression
            const cleanExpr = expression.toLowerCase().replace(/\s/g, '');
            
            // Validate basic format
            if (!cleanExpr || cleanExpr.length === 0) {
                return { valid: false, error: 'Empty expression' };
            }
            
            // Parse dice terms and modifier
            const diceTerms = [];
            let modifier = 0;
            
            try {
                // Split by + and - while preserving the operators
                const parts = cleanExpr.split(/([+\-])/);
                let currentSign = 1;
                
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i].trim();
                    
                    if (part === '+') {
                        currentSign = 1;
                    } else if (part === '-') {
                        currentSign = -1;
                    } else if (part && part !== '') {
                        if (part.includes('d')) {
                            // Dice term
                            const diceMatch = part.match(/^(\d*)d(\d+)$/);
                            if (diceMatch) {
                                const count = parseInt(diceMatch[1]) || 1;
                                const sides = parseInt(diceMatch[2]);
                                
                                if (count <= 0 || count > 50) {
                                    return { valid: false, error: 'Dice count must be between 1-50' };
                                }
                                if (sides <= 0 || sides > 1000) {
                                    return { valid: false, error: 'Dice sides must be between 1-1000' };
                                }
                                
                                if (currentSign < 0) {
                                    return { valid: false, error: 'Cannot subtract dice (use negative modifiers instead)' };
                                }
                                
                                diceTerms.push({ 
                                    count: count, 
                                    sides: sides
                                });
                            } else {
                                return { valid: false, error: `Invalid dice format: ${part}` };
                            }
                        } else {
                            // Modifier
                            const modValue = parseInt(part);
                            if (isNaN(modValue)) {
                                return { valid: false, error: `Invalid modifier: ${part}` };
                            }
                            modifier += modValue * currentSign;
                        }
                    }
                }
                
                if (diceTerms.length === 0) {
                    return { valid: false, error: 'Expression must contain at least one dice term' };
                }
                
                // Check total dice limit
                const totalDice = diceTerms.reduce((sum, term) => sum + term.count, 0);
                if (totalDice > 50) {
                    return { valid: false, error: 'Total dice count cannot exceed 50' };
                }
                
                return {
                    valid: true,
                    diceTerms: diceTerms,
                    modifier: modifier
                };
            } catch (e) {
                return { valid: false, error: 'Invalid expression format' };
            }
        }

        function buildExpressionFromTerms(diceTerms, modifier) {
            let expression = '';
            
            // Add dice terms
            diceTerms.forEach((term, index) => {
                if (index > 0) expression += '+';
                expression += `${term.count}d${term.sides}`;
            });
            
            // Add modifier
            if (modifier > 0) {
                expression += `+${modifier}`;
            } else if (modifier < 0) {
                expression += `${modifier}`;
            }
            
            return expression;
        }

        function combineWithExistingDice(expression, newDiceSides) {
            try {
                // Parse the existing expression
                const parsed = parseDiceExpression(expression);
                if (!parsed.valid) {
                    // If parsing fails, just append
                    return expression + `+1d${newDiceSides}`;
                }
                
                // Look for existing dice of the same type
                let foundExisting = false;
                const combinedDiceTerms = parsed.diceTerms.map(term => {
                    if (term.sides === newDiceSides && !foundExisting) {
                        foundExisting = true;
                        return {
                            ...term,
                            count: term.count + 1
                        };
                    }
                    return term;
                });
                
                // If no existing dice of this type, add new term
                if (!foundExisting) {
                    combinedDiceTerms.push({
                        count: 1,
                        sides: newDiceSides
                    });
                }
                
                // Rebuild the expression
                return buildExpressionFromTerms(combinedDiceTerms, parsed.modifier);
            } catch (e) {
                // Fallback to simple append
                return expression + `+1d${newDiceSides}`;
            }
        }

        // Test Suite
        const tests = [];
        const resultsDiv = document.getElementById('test-results');

        function addTest(name, testFn) {
            tests.push({ name, testFn });
        }

        function runTest(name, testFn) {
            try {
                const result = testFn();
                if (result.pass) {
                    return `<div class="test-result test-pass">‚úÖ ${name}: ${result.message || 'PASS'}</div>`;
                } else {
                    return `<div class="test-result test-fail">‚ùå ${name}: ${result.message || 'FAIL'}</div>`;
                }
            } catch (error) {
                return `<div class="test-result test-fail">‚ùå ${name}: ERROR - ${error.message}</div>`;
            }
        }

        function runAllTests() {
            let html = '';
            
            // Parsing Tests
            html += '<div class="test-section"><h2>üîç Expression Parsing Tests</h2>';
            
            // Valid expressions
            const validExpressions = [
                '1d20',
                '1d20+5',
                '2d6+1d4+3',
                '1d6+1d4',
                '3d8-2',
                'd6',
                'D20+5',
                '1D6 + 1D4 + 2'
            ];
            
            validExpressions.forEach(expr => {
                html += runTest(`Parse "${expr}"`, () => {
                    const result = parseDiceExpression(expr);
                    return {
                        pass: result.valid,
                        message: result.valid ? `‚úì Parsed successfully` : `‚úó ${result.error}`
                    };
                });
            });
            
            // Invalid expressions
            const invalidExpressions = [
                '',
                'abc',
                '1d',
                'd',
                '1d0',
                '0d6',
                '51d6', // Too many dice
                '1d1001', // Too many sides
                '-1d6' // Negative dice
            ];
            
            invalidExpressions.forEach(expr => {
                html += runTest(`Reject "${expr}"`, () => {
                    const result = parseDiceExpression(expr);
                    return {
                        pass: !result.valid,
                        message: !result.valid ? `‚úì Correctly rejected: ${result.error}` : '‚úó Should have been rejected'
                    };
                });
            });
            
            html += '</div>';
            
            // Smart Combination Tests
            html += '<div class="test-section"><h2>üß† Smart Dice Combination Tests</h2>';
            
            const combinationTests = [
                {
                    start: '1d4',
                    add: 4,
                    expected: '2d4',
                    description: '1d4 + d4 = 2d4'
                },
                {
                    start: '1d6+1d4',
                    add: 4,
                    expected: '1d6+2d4',
                    description: '1d6+1d4 + d4 = 1d6+2d4'
                },
                {
                    start: '2d6+3',
                    add: 6,
                    expected: '3d6+3',
                    description: '2d6+3 + d6 = 3d6+3'
                },
                {
                    start: '1d20+5',
                    add: 8,
                    expected: '1d20+1d8+5',
                    description: '1d20+5 + d8 = 1d20+1d8+5'
                },
                {
                    start: '1d4+1d6+1d8',
                    add: 6,
                    expected: '1d4+2d6+1d8',
                    description: '1d4+1d6+1d8 + d6 = 1d4+2d6+1d8'
                }
            ];
            
            combinationTests.forEach(test => {
                html += runTest(test.description, () => {
                    const result = combineWithExistingDice(test.start, test.add);
                    return {
                        pass: result === test.expected,
                        message: result === test.expected ? 
                            `‚úì ${test.start} + d${test.add} = ${result}` :
                            `‚úó Expected "${test.expected}", got "${result}"`
                    };
                });
            });
            
            html += '</div>';
            
            // Expression Rebuild Tests
            html += '<div class="test-section"><h2>üîß Expression Rebuild Tests</h2>';
            
            const rebuildTests = [
                {
                    diceTerms: [{count: 1, sides: 20}],
                    modifier: 5,
                    expected: '1d20+5'
                },
                {
                    diceTerms: [{count: 2, sides: 6}, {count: 1, sides: 4}],
                    modifier: 0,
                    expected: '2d6+1d4'
                },
                {
                    diceTerms: [{count: 1, sides: 8}],
                    modifier: -2,
                    expected: '1d8-2'
                },
                {
                    diceTerms: [{count: 3, sides: 6}],
                    modifier: 0,
                    expected: '3d6'
                }
            ];
            
            rebuildTests.forEach((test, index) => {
                html += runTest(`Rebuild Expression ${index + 1}`, () => {
                    const result = buildExpressionFromTerms(test.diceTerms, test.modifier);
                    return {
                        pass: result === test.expected,
                        message: result === test.expected ?
                            `‚úì Built "${result}"` :
                            `‚úó Expected "${test.expected}", got "${result}"`
                    };
                });
            });
            
            html += '</div>';
            
            // Round-trip Tests
            html += '<div class="test-section"><h2>üîÑ Round-trip Tests</h2>';
            
            const roundTripExpressions = [
                '1d20+5',
                '2d6+1d4+3',
                '1d8-2',
                '3d6',
                '1d4+1d6+1d8+1d10+1d12+1d20'
            ];
            
            roundTripExpressions.forEach(expr => {
                html += runTest(`Round-trip "${expr}"`, () => {
                    const parsed = parseDiceExpression(expr);
                    if (!parsed.valid) {
                        return { pass: false, message: `Parse failed: ${parsed.error}` };
                    }
                    
                    const rebuilt = buildExpressionFromTerms(parsed.diceTerms, parsed.modifier);
                    const reParsed = parseDiceExpression(rebuilt);
                    
                    if (!reParsed.valid) {
                        return { pass: false, message: `Re-parse failed: ${reParsed.error}` };
                    }
                    
                    // Compare the parsed structures
                    const structuresMatch = 
                        JSON.stringify(parsed.diceTerms) === JSON.stringify(reParsed.diceTerms) &&
                        parsed.modifier === reParsed.modifier;
                    
                    return {
                        pass: structuresMatch,
                        message: structuresMatch ?
                            `‚úì ${expr} ‚Üí ${rebuilt} ‚Üí same structure` :
                            `‚úó ${expr} ‚Üí ${rebuilt} ‚Üí structure mismatch`
                    };
                });
            });
            
            html += '</div>';
            
            resultsDiv.innerHTML = html;
        }

        // Run tests on page load
        runAllTests();
    </script>
</body>
</html>
